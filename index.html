<!-- language: html -->    
<!doctype html>    
<html lang="ar" dir="rtl">    
<head>    
<meta charset="utf-8">    
<title>Arabic SAP Text Cleaner</title>    
<style>    
  body{font-family: Arial, "Noto Naskh Arabic", Tahoma; margin:20px}    
  textarea{width:100%; height:220px; direction: rtl}    
  .row{margin:12px 0}    
  label{display:block; margin-bottom:6px}    
  table{border-collapse: collapse; width:100%}    
  th,td{border:1px solid #ccc; padding:6px}    
</style>    
</head>    
<body>    
<h2>Arabic SAP Text Cleaner</h2>    
    
<div class="row">    
  <label>Paste SAP rows (one per line):</label>    
  <textarea id="raw"></textarea>    
</div>    
    
<div class="row">    
  <label>Tokens (space-joiners):</label>    
  <input id="tokens" style="width:100%" value="شركة, مؤسسة, تموينات, أسواق, بقالة, محطة, فرع, مركز, مطعم, سوق, ثلاجة">    
</div>    
    
<div class="row">    
  <label>Patterns (regex, comma-separated):</label>    
  <input id="patterns" style="width:100%" value="CA:\d+,Payment-[A-Z0-9\-]+,SAINMAIN\w+,SANCBK\w+,SARIBL\w+|RIBL\w+,[A-Z]{2,}\d[\w\-]+">    
</div>    
    
<div class="row">    
  <button onclick="process()">Process</button>    
  <button onclick="downloadXLSX()">Download XLSX</button>    
  <button onclick="downloadCSV()">Download CSV</button>    
</div>    
    
<div class="row">    
  <table id="out"><thead></thead><tbody></tbody></table>    
</div>    
    
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>    
<script>    
const norm = (s, opts={alef:true, tatweel:true, ya:false})=>{    
  if (!s) return '';    
  let t = s;    
  if (opts.tatweel) t = t.replace(/ـ/g,'');    
  if (opts.alef)    t = t.replace(/[إأآا]/g,'ا');    
  if (opts.ya){ t = t.replace(/ى/g,'ي').replace(/ئ/g,'ي'); }    
  t = t.replace(/ؤ/g,'و');    
  return t.trim();    
};    
const smartSpace = (s, toks=[])=>{    
  let t = s;    
  toks.forEach(tok=>{    
    const re = new RegExp(tok.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'); // escape    
    t = t.replace(re, ' ' + tok + ' ');    
  });    
  return t.split(/\s+/).filter(Boolean).join(' ');    
};    
const extract = (raw, patterns)=>{    
  // time    
  const m = raw.match(/^\((\d{2}):(\d{2})\)/);    
  let time = null, after = raw;    
  if (m){ time = `${m[1]}:${m[2]}`; after = raw.slice(m[0].length); }    
  // codes    
  let codes = [];    
  patterns.forEach(p=>{    
    try{    
      const re = new RegExp(p,'g');    
      const found = after.match(re);    
      if (found) codes = codes.concat(found);    
      after = after.replace(re, '');    
    }catch(e){}    
  });    
  codes = [...new Set(codes)];    
  return { time, text: after.trim(), codes };    
};    
    
let rows = [];    
function process(){    
  const raw = document.getElementById('raw').value || '';    
  const toks = document.getElementById('tokens').value.split(',').map(x=>x.trim()).filter(Boolean);    
  const pats = document.getElementById('patterns').value.split(',').map(x=>x.trim()).filter(Boolean);    
    
  rows = [];    
  raw.split(/\r?\n/).forEach(line=>{    
    line = line.trim();    
    if(!line) return;    
    const {time, text, codes} = extract(line, pats);    
    let parts = text.split('/').map(s=>s.trim()).filter(Boolean);    
    let partsNorm = parts.map(p=> smartSpace(norm(p), toks));    
    const normalizedName = partsNorm.join(' / ');    
    const hasPayment = partsNorm.some(p=> p.includes('Payment'));    
    const tooShort = partsNorm.some(p=> p.length < 3);    
    const flag = !time ? 'NoTime' : hasPayment ? 'CodeResidue' : (tooShort ? 'ShortPart' : '');    
    rows.push({    
      Time: time || '',    
      Name1: partsNorm[0] || '',    
      Name2: partsNorm[1] || '',    
      Name3: partsNorm[2] || '',    
      Codes: codes.join(' | '),    
      Text: line,    
      NormalizedName: normalizedName,    
      Flag: flag    
    });    
  });    
  render(rows);    
}    
    
function render(data){    
  const th = document.querySelector('#out thead');    
  const tb = document.querySelector('#out tbody');    
  th.innerHTML = '';    
  tb.innerHTML = '';    
  if(!data.length) return;    
  const cols = Object.keys(data[0]);    
  th.innerHTML = '<tr>' + cols.map(c=>`<th>${c}</th>`).join('') + '</tr>';    
  data.forEach(r=>{    
    const tr = document.createElement('tr');    
    cols.forEach(c=>{    
      const td = document.createElement('td');    
      td.textContent = (r[c]==null?'':r[c]);    
      tr.appendChild(td);    
    });    
    tb.appendChild(tr);    
  });    
}    
    
function downloadXLSX(){    
  if(!rows.length) return;    
  const ws = XLSX.utils.json_to_sheet(rows);    
  const wb = XLSX.utils.book_new();    
  XLSX.utils.book_append_sheet(wb, ws, 'Output');    
  XLSX.writeFile(wb, 'Output_cleaned.xlsx');    
}    
function downloadCSV(){    
  if(!rows.length) return;    
  const cols = Object.keys(rows[0]);    
  const csv = [cols.join(',')].concat(    
    rows.map(r=> cols.map(c=>{    
      const v = (r[c]==null?'':String(r[c])).replace(/"/g,'""');    
      return `"${v}"`;    
    }).join(','))    
  ).join('\r\n');    
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});    
  const a = document.createElement('a');    
  a.href = URL.createObjectURL(blob);    
  a.download = 'Output_cleaned.csv';    
  a.click();    
}    
</script>    
</body>    
</html>    